---
title: "Modèle de gestion adaptative du loup"
author: "Olivier Gimenez & Loïc Pages"
date: "12/01/2024"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

Nous allons ici reprendre différents modèles d'estimation de population : le modèle exponentiel et le modèle logistique. Ces modèles seront appliqués à la population de loups en France. Nous allons également y ajouter un cadre prédictionnel dans une optique de gestion adaptative sur un intervalle de temps de 2 ans. L'efficacité des deux modèles sera comparée par le DIC.

Les modèle exponentiel d'estimation utilisé dans ce code provient de l'article de Andrén et al.

Dans un dernier temps, nous simulerons des données à l'aide des paramètres estimés afin de voir si les estimations collent avec tous types de données. Puis nous pourrons faire une projection sur 20 ans avec les deux types de modèle.

# Estimation d'effectif par Capture-Recapture

```{r}
library(R2jags)
library(tidyverse)
```

```{r}
modelCMR = function() {
 
  #--------------------------------------
  # Parameters:
  # phi: survival probability
  # gamma: removal entry probability
  # p: capture probability
  #--------------------------------------
  # States (S):
  # 1 not yet entered
  # 2 alive
  # 3 dead
  # Observations (O):
  # 1 seen 
  # 2 not seen
  #--------------------------------------
  
  # Priors and constraints
  for (t in 1:(n.occasions-1)){
    phi[t] <- mean.phi
    gamma[t] ~ dunif(0, 1) # Prior for entry probabilities
    p1[t] = mean.p1
    # p2[t] = mean.p2
    p2[t] ~ dunif(0,p1[t])
  }
  
  mean.p1 ~ dunif(0, 1) # Prior for mean capture
  #mean.p2 ~ dunif(0,mean.p1)
  mean.phi ~ dunif(0, 1)    # Prior for mean survival
  pi ~ dunif(0,1)
  
  # Define state-transition and observation matrices 	
  for (i in 1:M){  
    # Define probabilities of state S(t+1) given S(t)
    for (t in 1:(n.occasions-1)){
      ps[1,i,t,1] <- 1-gamma[t]
      ps[1,i,t,2] <- gamma[t]
      ps[1,i,t,3] <- 0
      ps[2,i,t,1] <- 0
      ps[2,i,t,2] <- phi[t]
      ps[2,i,t,3] <- 1-phi[t]
      ps[3,i,t,1] <- 0
      ps[3,i,t,2] <- 0
      ps[3,i,t,3] <- 1
      
      # Define probabilities of O(t) given S(t)
      po[1,i,t,1,1] <- 0
      po[1,i,t,2,1] <- 1
      po[2,i,t,1,1] <- p1[t]
      po[2,i,t,2,1] <- 1-p1[t]
      po[3,i,t,1,1] <- 0
      po[3,i,t,2,1] <- 1
      
      po[1,i,t,1,2] <- 0
      po[1,i,t,2,2] <- 1
      po[2,i,t,1,2] <- p2[t]
      po[2,i,t,2,2] <- 1-p2[t]
      po[3,i,t,1,2] <- 0
      po[3,i,t,2,2] <- 1
    } #t
  } #i
  
  # Likelihood 
  for (i in 1:M){
    group[i] ~ dbern(pi)
    # Define latent state at first occasion
    z[i,1] <- 1   # Make sure that all M individuals are in state 1 at t=1
    for (t in 2:n.occasions){
      # State process: draw S(t) given S(t-1)
      z[i,t] ~ dcat(ps[z[i,t-1], i, t-1,])
      # Observation process: draw O(t) given S(t)
      y[i,t] ~ dcat(po[z[i,t], i, t-1, ,group[i]+1])
    } #t
  } #i
  
  # Calculate derived population parameters
  for (t in 1:(n.occasions-1)){
    qgamma[t] <- 1-gamma[t]
  }
  cprob[1] <- gamma[1]
  for (t in 2:(n.occasions-1)){
    cprob[t] <- gamma[t] * prod(qgamma[1:(t-1)])
  } #t
  psi <- sum(cprob[])            # Inclusion probability
  for (t in 1:(n.occasions-1)){
    b[t] <- cprob[t] / psi      # Entry probability
  } #t
  
  for (i in 1:M){
    for (t in 2:n.occasions){
      al[i,t-1] <- equals(z[i,t], 2)
    } #t
    for (t in 1:(n.occasions-1)){
      d[i,t] <- equals(z[i,t]-al[i,t],0)
    } #t   
    alive[i] <- sum(al[i,])
  } #i
  
  for (t in 1:(n.occasions-1)){
    N[t] <- sum(al[,t])        # Actual population size
    B[t] <- sum(d[,t])         # Number of entries
  } #t
  for (i in 1:M){
    w[i] <- 1-equals(alive[i],0)
  } #i
  Nsuper <- sum(w[])            # Superpopulation size
}
```

## Simulation de données

Données de simulation
```{r}
n.occasions <- 7                        # Number of capture occasions
N <- 400                                 # Superpopulation size
phi <- rep(0.7, n.occasions-1)           # Survival probabilities
b <- c(0.34, rep(0.11, n.occasions-1))   # Entry probabilities 
p <- rep(0.5, n.occasions)               # Capture probabilities

PHI <- matrix(rep(phi, (n.occasions-1)*N), ncol = n.occasions-1, nrow = N, byrow = T)
P <- matrix(rep(p, n.occasions*N), ncol = n.occasions, nrow = N, byrow = T)
```

Fonction qui simule des données de Capture-Recapture sous le modèle JS.
```{r}
simul.js <- function(PHI, P, b, N){
  B <- rmultinom(1, N, b) # Generate no. of entering ind. per occasion
  n.occasions <- dim(PHI)[2] + 1
  CH.sur <- CH.p <- matrix(0, ncol = n.occasions, nrow = N)
  # Define a vector with the occasion of entering the population
  ent.occ <- numeric()
  for (t in 1:n.occasions){
    ent.occ <- c(ent.occ, rep(t, B[t]))
  }
  # Simulating survival
  for (i in 1:N){
    CH.sur[i, ent.occ[i]] <- 1   # Write 1 when ind. enters the pop.
    if (ent.occ[i] == n.occasions) next
    for (t in (ent.occ[i]+1):n.occasions){
      # Bernoulli trial: has individual survived occasion?
      sur <- rbinom(1, 1, PHI[i,t-1])
      ifelse (sur==1, CH.sur[i,t] <- 1, break)
    } #t
  } #i
  # Simulating capture
  for (i in 1:N){
    CH.p[i,] <- rbinom(n.occasions, 1, P[i,])
  } #i
  # Full capture-recapture matrix
  CH <- CH.sur * CH.p
  
  # Remove individuals never captured
  cap.sum <- rowSums(CH)
  never <- which(cap.sum == 0)
  CH <- CH[-never,]
  Nt <- colSums(CH.sur)    # Actual population size
  return(list(CH=CH, B=B, N=Nt))
}

```

Lancer la simulation
```{r}
sim <- simul.js(PHI, P, b, N)
CH <- sim$CH
```

Préparation des données
```{r}
# Add dummy occasion
CH.du <- cbind(rep(0, dim(CH)[1]), CH)

my.z.init <- CH.du

first.one <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1)))
last.one  <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) max(which(x == 1)))

for(i in 1:nrow(my.z.init)) {
  my.z.init[i, first.one[i]  : last.one[i]] = 2                           
  # 2 indique que l'on est sûr que l'individu est vivant
  if(first.one[i] > 1) my.z.init[i,1  : (first.one[i] - 1) ] = 1          
  # 1 indique que l'on n'a toujours pas observé l'individu (pas observé ou pas encore né)
  if(last.one[i] < ncol(my.z.init)) my.z.init[i, (last.one[i] + 1) : ncol(my.z.init)    ] = 3 
  # 3 indique que l'on n'observe plus l'individu (pas observé ou mort)
}

# Augment data
nz <- 150

CH.ms <- rbind(CH.du, matrix(0, ncol = dim(CH.du)[2], nrow = nz))

# Recode CH matrix: a 0 is not allowed in WinBUGS!
CH.ms[CH.ms==0] <- 2                     # Not seen = 2, seen = 1

my.z.init.ms <- rbind(my.z.init, matrix(0, ncol = dim(my.z.init)[2], nrow = nz))
my.z.init.ms[my.z.init.ms==0] <- 1
```

Préparation des paramètres jags
```{r}
# Initialisation des données
bugs.data = list(n.occasions = dim(CH.ms)[2],
                 y = CH.ms,
                 M = dim(CH.ms)[1])


# Parameters JAGS
bugs.monitor = c("mean.p1","mean.p2","p2" ,"mean.phi", "b", "Nsuper", "N", "B")
bugs.chains = 2


bugs.inits = function() {
  list(mean.phi = runif(1, 0, 1),
       mean.p1 = runif(1, 0, 1),
       mean.p2 = runif(1, 0, 1),
       z = cbind(rep(NA, dim(my.z.init.ms)[1]), my.z.init.ms[,-1]))
}

# Lancement du modèle
wolf_modelCMR = jags(data = bugs.data,
                     inits = bugs.inits, 
                     parameters.to.save = bugs.monitor,
                     model.file = modelCMR,
                     n.chains = bugs.chains, 
                     n.thin=1,
                     n.iter=2000, 
                     n.burnin=500)
```

```{r}
print(wolf_modelCMR, intervals = c(2.5/100, 50/100, 97.5/100))
```

# Données CMR du loup

```{r}
setwd("/media/loic/Commun/Travail/Stage CEFE 2024/Wolf_Model")
CMR=readRDS("CMR/dat/cmrlouphiver.rds")

CH=data.matrix(CMR)

n.occasions = dim(CH)[2]
```

Add dummy occasion
```{r}
CH.du <- cbind(rep(0, dim(CH)[1]), CH)

z.init <- CH.du

first.one <- apply(z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1)))
last.one  <- apply(z.init[,1:ncol(CH.du)], 1, function(x) max(which(x == 1)))

for(i in 1:nrow(z.init)) {
  z.init[i, first.one[i]  : last.one[i]] = 2                           # 2 indique que l'on est sûr que l'individu est vivant
  if(first.one[i] > 1) z.init[i,1  : (first.one[i] - 1) ] = 1          # 1 indique que l'on n'a toujours pas observé l'individu (pas observé ou pas encore né)
  if(last.one[i] < ncol(z.init)) z.init[i, (last.one[i] + 1) : ncol(z.init)    ] = 3 # 3 indique que l'on n'observe plus l'individu (pas observé ou mort)
}
```

Augment data
```{r}
nz <- 150
aug = matrix(0, ncol = dim(CH.du)[2], nrow = nz)
CH.ms = rbind(CH.du, aug)
```

Recode CH matrix: a 0 is not allowed in WinBUGS!
```{r}
CH.ms[CH.ms == 0] = 2             # Not seen = 2, seen = 1
# Il y avait déjà des 2 dans les données, indiquant qu'un individu est mort. Cette information supplémentaire est mise de côté pour le moment

z.init.ms = rbind(z.init, aug)
z.init.ms[z.init.ms == 0] = 1
```

Paramètres jags
```{r}
# Initialisation des données
bugs.data = list(n.occasions = dim(CH.ms)[2],
                 y = CH.ms,
                 M = dim(CH.ms)[1])

# Parameters JAGS
bugs.monitor = c("mean.p1","p2", "mean.phi", "b", "Nsuper", "N", "B")
bugs.chains = 2

bugs.inits = function() {
  list(mean.phi = runif(1, 0, 1),
    mean.p1 = runif(1, 0, 1),
    mean.p2 = runif(1, 0, 1),
    z = cbind(rep(NA, dim(z.init.ms)[1]), z.init.ms[, -1])
  )
}

# Lancement du modèle (un peu long : ~1h30)
wolf_modelCMR = jags(data = bugs.data,
                     inits = bugs.inits, 
                     parameters.to.save = bugs.monitor,
                     model.file = modelCMR,
                     n.chains = bugs.chains, 
                     n.thin=1,
                     n.iter=1000, 
                     n.burnin=250)
```

```{r}
print(wolf_modelCMR, intervals = c(2.5/100, 50/100, 97.5/100))
```

```{r}
a= wolf_modelCMR$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               values_to = "value",
               names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  filter(!row_number(23)) %>% 
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter) + 1995)%>%
  arrange(years)
a
```

# Estimation et projection

## Préparation

### Les données

Estimations d'effectifs par CMR :
```{r}
CMR <- c(17.1,35.4,47.7,25.1,62.6,47.9,81.7,110.5,102.7,135.9,132.6,101.7,130.3,
141.4,141.5,175.5,210.3,174.5,353.6,280.2,376.7,561.2,571.9,682.4,645.7,783.8,868)
```

Nombre de prélèvements :
```{r}
harvest <- c(0,0,0,0,0,1,0,0,2,1,2,0,0,1,0,4,4,6,18,36,34,42,51,98,105,103,169)
```

Erreur d'observation :
```{r}
ObsSE = rep(0.3, 27)
se = read_csv("se.csv",
              show_col_types = FALSE,
              col_names = c("years", "lq", "N", "hq")) %>%
  reframe(se = (hq - N) / 1.96)

```

On met ensemble les effectifs estimés par CMR ainsi que les nombres de loups tués.
```{r}
dat <- cbind(round(CMR), ObsSE, harvest)
colnames(dat) <- c("N", "se", "H")
dat <- as.data.frame(dat)
nyears <- nrow(dat)
dat
```

# Modèles d'estimation et de prédiction à cours terme

## Modèle exponentiel

Dans ce modèle, l'effectif de la population suit une croissance exponentielle. On soustrait le nombre de prélèvement à l'effectif de la population au temps $t-1$ puis on le multiplie par le taux de reproduction $\lambda$. On obtient l'effectif de la population au temps $t$.
$$N_{t} = \lambda (N_{t-1} - H_{t-1}).$$
On ajoute à cette relation déterministe de la stochasticité. Ici l'effectif de la population au temps $t$ suit un loi log-normale, c'est à dire que les effectifs sont normalement distribués sur l'échelle log :
$$\log(N_{t}) \sim \text{Normale}(\mu_{t}, \sigma_{\text{proc}})$$
avec la moyenne $\mu_{t} = \log(N_{t}) = \log(\lambda (N_{t-1} - H_{t-1}))$ et $\sigma_{\text{proc}}$ l'erreur standard des effectifs.
On utilise une loi log-normale plutôt qu'une loi de Poisson car les estimations semblent être plus précises et suivent mieux les données observées.

On ajoute les effectifs observés $y_t$ qui suivent une loi de Poisson de paramètre l'effectif estimé au temps $t$.
$$y_t \sim \text{Poisson}(N_t).$$
On modélise tout ça en bayésien :

```{r}
modelexp = function() {
  # Priors
  #sigmaProc ~ dunif (0, 10)
  #tauProc = 1 / sigmaProc ^ 2
  lambda ~ dunif(0, 5)
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    tauProc[t] = 1 / sigmaProc[t-1] ^ 2
    mu[t] = lambda * (N[t-1] - h[t-1])
    NProc[t] = log(max(1, mu[t]))
    N[t] ~ dlnorm(NProc[t], tauProc[t])
  }
  
  # Observation model
  for (t in 1:nyears) {
    y[t] ~ dpois(N[t])
  }
}
```

Initialisation des données :
```{r}
bugs.data = list(
  nyears = nrow(dat),
  y = dat$N,
  h = dat$H,
  sigmaProc = c(se$se,100)
)
```

Paramètres JAGS :
```{r}
bugs.monitor = c("lambda", "sigmaProc", "N", "tauProc")
bugs.chains = 3
bugs.inits = function() {
  list()
}
```

Lancement du modèle.
```{r}
wolf_modelexp = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modelexp,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=100000, 
                   n.burnin=50000)
```

On affiche les estimations obtenus.
```{r}
print(wolf_modelexp, intervals = c(2.5/100, 50/100, 97.5/100))
```

On affiche la dynamique de la population sur un graphique.
```{r}
wolf_modelexp$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               values_to = "value",
               names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter) + 1995)%>%
  arrange(years)%>%
  ggplot()+
  geom_line(aes(x = years, y = medianN), colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq, ymax = hq), fill = "red", alpha = 0.3)+
  geom_point(data = bugs.data %>% as_tibble, aes(x = 1995 + 1:unique(nyears), y = y)) + 
  coord_cartesian(xlim=c(1996,2022),ylim=c(0,1250))+
  theme_bw()+
  labs(title = "Estimated population size",
       subtitle = "Observed population size (black dots)",
       x = "Years",
       y = "Number of wolves")

```

### Projection
On va maintenant ajouter une projection sur 2 ans pour différents taux de prélèvement :

```{r}
dH = c(0, 0.10, 0.20, 0.30)
```

Le modèle est le même que précédemment à l'exeption de la partie Projected model qui ajoute les prédicitions au modèle.

```{r}
modelexp = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / sigmaProc ^ 2
  lambda ~ dunif(0, 5)
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    mu[t] = lambda * (N[t - 1] - h[t - 1])
    NProc[t] = log(max(1, mu[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  
  # Observation model
  for (t in 1:nyears) {
    y[t] ~ dpois(N[t])
  }
  
  # Projected model
  for (t in (nyears + 1):(nyears + 2)) {
    mu[t] = (lambda - dH) * N[t - 1]
    NProc[t] = log(max(1, mu[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
}
```

On lance la machine pour chaque taux de prélevement.

```{r,results='hide'}
for (i in 1:4) {
  # Initialisation des données
  bugs.data = list(
    nyears = nrow(dat),
    y = c(dat$N, rep(NA, 2)),
    dH = dH[i],
    h = dat$H
  )
  
  # Paramètres jags
  bugs.monitor = c("lambda", "sigmaProc", "N", "tauProc")
  bugs.chains = 3
  bugs.inits = function() {
    list()
  }
  
# Lancement du modèle

wolf_modelexp = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modelexp,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=100000, 
                   n.burnin=50000)

if (i==1){
output1 = wolf_modelexp$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter1") %>%
  filter(str_detect(parameter1, "N")) %>%
  group_by(parameter1) %>%
  summarize(medianN1 = median(value),
            lq1 = quantile(value, probs = 2.5/100),
            hq1 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter1) + 1995)%>%
  arrange(years)%>%
  mutate(ObsY = bugs.data$y)
}

if(i==2){
  output2 = wolf_modelexp$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter2") %>%
  filter(str_detect(parameter2, "N")) %>%
  group_by(parameter2) %>%
  summarize(medianN2 = median(value),
            lq2 = quantile(value, probs = 2.5/100),
            hq2 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter2) + 1995)%>%
  arrange(years)
}

if(i==3){
  output3 = wolf_modelexp$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter3") %>%
  filter(str_detect(parameter3, "N")) %>%
  group_by(parameter3) %>%
  summarize(medianN3 = median(value),
            lq3 = quantile(value, probs = 2.5/100),
            hq3 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter3) + 1995)%>%
  arrange(years) 
}

if(i==4){
  output4 = wolf_modelexp$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter4") %>%
  filter(str_detect(parameter4, "N")) %>%
  group_by(parameter4) %>%
  summarize(medianN4 = median(value),
            lq4 = quantile(value, probs = 2.5/100),
            hq4 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter4) + 1995)%>%
  arrange(years)
}
}
```

On affiche les courbes d'effectifs :

```{r,warning=FALSE}
output = output1 %>% left_join(output2) %>%
  left_join(output3) %>%
  left_join(output4) %>%
  pivot_longer(
    c(medianN1, medianN2, medianN3, medianN4),
    names_to = "medianN",
    values_to = "valuesM")

variable_names <- list(
  "medianN1" = "Harvest : 0%" ,
  "medianN2" = "Harvest : 10%",
  "medianN3" = "Harvest : 20%",
  "medianN4" = "Harvest : 30%")

variable_labeller <- function(variable, value) {
  return(variable_names[value])
}

  ggplot(output)+
  geom_point(aes(x = years, y = ObsY)) + 
  coord_cartesian(xlim=c(1996,2023),ylim=c(0,1250))+
  aes(x = years, y = valuesM)+
  geom_line(colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq1, ymax = hq1), fill = "red", alpha = 0.3)+
  facet_wrap(~medianN,labeller = variable_labeller)+
  theme_bw()+
  labs(title = "Estimated and projected population size for each harest rate",
       x = "Years",
       y = "Number of wolves")
```

On définit un objectif d'un maximum d'effectifs à 1250, et un minimum à 1000.
Pour atteindre cet objectif on peut imposer un taux de prélèvement de 0% ou 10% sur 2 ans.

## Modèle logistique

On définit ici d'abordDans ce modèle, l'effectif de la population suit une croissance logistique, c'est à dire que la population croit de manière exponentielle puis est limitée par une capacité de charge.
On soustrait le nombre de prélevements à l'effectif de la population au temps $t-1$. Puis en utilisant ce résultat on calcule $$\lambda_{t} = N_{t-1} \times \exp(\alpha(1-\frac{N_{t-1}}{K})$$, avec $K$ la capactié de charge.

On ajoute à cette relation déterministe de la stochasticité. L’effectif de la population au temps t suit une
loi log-normale, c’est à dire que les effectifs sont normalement distribués sur l’échelle log :

$$log(N_t) \sim \text{Normale}(log(\lambda_{t-1}),\sigma_\text{proc})$$
avec $\sigma_\text{proc}$ l'erreur standard des effectifs.

On ajoute les effectifs observés yt qui suivent une loi de Poisson de paramètre l’effectif estimé au temps $t$.
$$y_t\sim\text{Poisson}(N_t)$$
Ce qui donne en bayésien :

```{r}
modellogist = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / sigmaProc ^ 2
  alpha ~ dunif(0, 1.0986) #maximum exponential growth rate
  K ~ dunif(1, 1000)         #carrying capacity
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    u[t-1] = N[t-1] - h[t-1]
    Er[t] = exp(alpha * (1 - u[t-1] / K)) # per capita growth rate is density dependent - Ricker model
    lambda[t] = u[t-1] * Er[t]
    NProc[t] = log(max(1, lambda[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  # Observation model
  for (t in 1:(nyears)) {
    y[t] ~ dpois(N[t])
  }
}
```

Initialisation des données :
```{r}
bugs.data = list(nyears = nrow(dat),
                 y = dat$N,
                 h = dat$H)
```

Paramètres JAGS :
```{r}
bugs.monitor = c("alpha", "sigmaProc", "tauProc", "K", "N")
bugs.chains = 3
init1 = list(alpha = .5, sigmaProc = .25)
init2 = list(alpha = .1, sigmaProc = .05)
init3 = list(alpha = 1, sigmaProc = .45)
bugs.inits = list(init1, init2, init3)
```

Lancement du modèle.
```{r}
wolf_modellogist = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modellogist,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=50000, 
                   n.burnin=10000)

```

On affiche les estimations obtenus.
```{r}
print(wolf_modellogist, intervals = c(2.5/100, 50/100, 97.5/100))
```

On affiche la dynamique de la population sur un graphique.
```{r}
wolf_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter) + 1995)%>%
  arrange(years)%>%
  ggplot()+
  geom_line(aes(x = years, y = medianN), colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq, ymax = hq), fill = "red", alpha = 0.3)+
  geom_point(data = bugs.data %>% as_tibble, aes(x = 1995 + 1:unique(nyears), y = dat$N)) + 
  coord_cartesian(xlim=c(1996,2022),ylim=c(0,1250))+
  theme_bw()+
  labs(title = "Estimated population size",
       subtitle = "Observed population size (black dots)",
       x = "Years",
       y = "Number of wolves")

```

### Projection

On va maintenant ajouter une projection sur 2 ans pour différents taux de prélèvement :

```{r}
dH = c(0, 0.10, 0.20, 0.30)
```

Le modèle est le même que précédemment à l'exeption de la partie Projected model qui ajoute les prédicitions au modèle.

```{r}
modellogist = function() {
  # Priors
  sigmaProc ~ dunif (0, 5)
  tauProc = 1 / sigmaProc ^ 2
  alpha ~ dunif(0, 1.0986) #maximum exponential growth rate
  K ~ dunif(1, 1000)         #carrying capacity
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    u[t-1] = N[t-1] - h[t-1]
    Er[t] = exp(alpha * (1 - u[t-1] / K)) # per capita growth rate is density dependent - Ricker model
    lambda[t] = u[t-1] * Er[t]
    NProc[t] = log(max(1, lambda[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  # Observation model
  for (t in 1:(nyears)) {
    y[t] ~ dpois(N[t])
  }
  #Projected population
    for (t in (nyears+1):(nyears+2)) {
    u[t-1] = (1-dH) * N[t-1]
    Er[t] = exp(alpha * (1 - u[t-1] / K)) # per capita growth rate is density dependent - Ricker model
    lambda[t] = u[t-1] * Er[t]
    NProc[t] = log(max(1, lambda[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
}
```

On lance la machine pour chaque taux et on affiche la courbe d'effectifs : 

```{r,results='hide'}
for (i in 1:4) {
  # Initialisation des données
  bugs.data = list(
    nyears = nrow(dat),
    y = c(dat$N, rep(NA, 2)),
    dH = dH[i],
    h = dat$H
  )
  
  # Paramètres jags
  bugs.monitor = c("alpha", "sigmaProc", "tauProc", "K", "N")
  bugs.chains = 3
  init1 = list(alpha = .5, sigmaProc = .25)
  init2 = list(alpha = .1, sigmaProc = .05)
  init3 = list(alpha = 1, sigmaProc = .45)
  bugs.inits = list(init1, init2, init3)
  
  # Lancement du modèle

wolf_modellogist = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modellogist,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=100000, 
                   n.burnin=50000)

if (i==1){
output1 = wolf_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter1") %>%
  filter(str_detect(parameter1, "N")) %>%
  group_by(parameter1) %>%
  summarize(medianN1 = median(value),
            lq1 = quantile(value, probs = 2.5/100),
            hq1 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter1) + 1995)%>%
  arrange(years)%>%
  mutate(ObsY = bugs.data$y)
}

if(i==2){
  output2 = wolf_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter2") %>%
  filter(str_detect(parameter2, "N")) %>%
  group_by(parameter2) %>%
  summarize(medianN2 = median(value),
            lq2 = quantile(value, probs = 2.5/100),
            hq2 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter2) + 1995)%>%
  arrange(years)
}

if(i==3){
  output3 = wolf_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter3") %>%
  filter(str_detect(parameter3, "N")) %>%
  group_by(parameter3) %>%
  summarize(medianN3 = median(value),
            lq3 = quantile(value, probs = 2.5/100),
            hq3 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter3) + 1995)%>%
  arrange(years) 
}

if(i==4){
  output4 = wolf_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter4") %>%
  filter(str_detect(parameter4, "N")) %>%
  group_by(parameter4) %>%
  summarize(medianN4 = median(value),
            lq4 = quantile(value, probs = 2.5/100),
            hq4 = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter4) + 1995)%>%
  arrange(years)
}
}
```

On affiche les estimations et projections pour chaque taux de prélevement :

```{r,warning=FALSE}
output = output1 %>% left_join(output2) %>%
  left_join(output3) %>%
  left_join(output4) %>%
  pivot_longer(
    c(medianN1, medianN2, medianN3, medianN4),
    names_to = "medianN",
    values_to = "valuesM")

variable_names <- list(
  "medianN1" = "Harvest : 0%" ,
  "medianN2" = "Harvest : 10%",
  "medianN3" = "Harvest : 20%",
  "medianN4" = "Harvest : 30%")

variable_labeller <- function(variable, value) {
  return(variable_names[value])
}

  ggplot(output)+
  geom_point(aes(x = years, y = ObsY)) + 
  coord_cartesian(xlim=c(1996,2023),ylim=c(0,1250))+
  aes(x = years, y = valuesM)+
  geom_line(colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq1, ymax = hq1), fill = "red", alpha = 0.3)+
  facet_wrap(~medianN,labeller = variable_labeller)+
  theme_bw()+
  labs(title = "Estimated and projected population size for each harest rate",
       x = "Years",
       y = "Number of wolves")
```

## Comparaison DIC des deux modèles

```{r,echo=FALSE}
modelexp = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / sigmaProc ^ 2
  lambda ~ dunif(0, 5)
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    mu[t] = lambda * (N[t-1] - h[t-1])
    NProc[t] = log(max(1, mu[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  
  # Observation model
  for (t in 1:nyears) {
    y[t] ~ dpois(N[t])
  }
}

modellogist = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / sigmaProc ^ 2
  alpha ~ dunif(0, 1.0986) #maximum exponential growth rate
  K ~ dunif(1, 1000)         #carrying capacity
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    u[t-1] = N[t-1] - h[t-1]
    Er[t] = exp(alpha * (1 - u[t-1] / K)) # per capita growth rate is density dependent - Ricker model
    lambda[t] = u[t-1] * Er[t]
    NProc[t] = log(max(1, lambda[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  # Observation model
  for (t in 1:(nyears)) {
    y[t] ~ dpois(N[t])
  }
}
```

Dans cette section on va comparer l'efficacité de chaque modèle selon le nombre de données, c'est-à-dire en fonction du temps passé.

On stocke les résultats du DIC de chaque modèle de la 10ème année jusqu'à la fin.

```{r,results='hide'}
DICexp=numeric(nrow(dat)-10)
DIClogist=numeric(nrow(dat)-10)

for (i in 10:nrow(dat)){
# Initialisation des données :
bugs.data = list(nyears = i,
                 y = dat$N[1:i],
                 h = dat$H[1:i])

# Modèle exponentiel
# Paramètres JAGS :
bugs.monitor = c("lambda", "sigmaProc", "N", "tauProc")
bugs.chains = 3
bugs.inits = function() {
  list()
}
#On lance la machine
wolf_modelexp = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modelexp,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=50000, 
                   n.burnin=20000)

# Enregistrement du DIC
DICexp[i-9]=wolf_modelexp$BUGSoutput$DIC
  
# Modèle logistique
# Paramètres JAGS
bugs.monitor = c("alpha", "sigmaProc", "tauProc", "K", "N")
bugs.chains = 3
init1 = list(alpha = .5, sigmaProc = .25)
init2 = list(alpha = .1, sigmaProc = .05)
init3 = list(alpha = 1, sigmaProc = .45)
bugs.inits = list(init1, init2, init3)

# On lance la machine
wolf_modellogist = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modellogist,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=20000, 
                   n.burnin=5000)

# Enregistrement du DIC
DIClogist[i-9]=wolf_modellogist$BUGSoutput$DIC
}
```

On affiche l'évolution des DIC des deux modèles au cours du temps.

```{r}
ggplot() +
  geom_point(aes(x = seq(10, 27), y = DICexp), colour = "blue") +
  geom_point(aes(x = seq(10, 27), y = DIClogist), colour = "red") +
  labs(
    title = "Evolution du DIC de l'année 10 à l'ensemble des 27 années",
    subtitle = "en bleue: modèle exponentiel ; en rouge: modèle logistique",
    x = "Years",
    y = "DIC") +
  theme_bw()
```

On constate que la différence d'efficacité entre les deux modèles n'est pas flagrante. Malgrès tout, le modèle exponentiel semble meilleur pour l'estimation des premières années, puis le modèle logistique est meilleur. Ce qui est logique avec la réalité biologique qui impose des limites d'espace et de ressources aux populations de loups. Celles-ci tendent donc à se stabiliser autour de la capacité de charge. 


# Simulation de données et prédiction

On va maintenant faire une simulation de données en fonction des paramètres obtenus par les estimations précédemment trouvées. 
On a une simulation suivant le modèle exponentiel, une autre suivant le modèle logistique, et une dernière suivant un mélange avec le modèle exponentiel sur les 15 premières années puis le modèle logistique sur la fin. 
Ces simulations permettent de voir si nos estimations précédentes peuvent bien reproduire un jeu de données similaire aux données observées. Nous pouvons ensuite faire une projection sur 20 ans afin de voir la dynamique proposée par chaque modèle.

## Avec le modèle exponentiel

On initialise les paramètres pour la simulation des données
```{r}
nyears = 27
N1 = 30
sigma = 0.15
lambda=1.15
```

On crée un data frame qui contiendra nos données.
```{r}
ssm_sim1 <- data.frame(Year = 1:nyears,
                       y = numeric(nyears),
                       N = numeric(nyears))

ssm_sim1$N[1] = N1
```

On crée les données pas à pas en multipliant les effectifs par le taux de reproduction $\lambda$.
On ajoute de la stochasticité avec $N_{t+1}\sim \text{Normale}(\lambda N_t,\sigma)$.

```{r}
for (t in 1:(nyears-1)){
   ssm_sim1$N[t+1] <- round(rnorm(1,ssm_sim1$N[t] * lambda,sigma))
}

for (t in 1:nyears){
  ssm_sim1$y[t]=rpois(1,ssm_sim1$N[t])
}

ggplot(ssm_sim1, aes(x = Year)) +
  geom_point(aes(y = y), colour = "red") +
  geom_line(aes(y = N), colour = "grey30") +
  theme_bw()
```

On va maintenant faire une estimation des données à l'aide du modèle exponentiel et projeter sur 20 ans.

```{r}
modelexp = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / (sigmaProc ^ 2)
  lambda ~ dunif(0, 5)
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    mu[t] = lambda * N[t-1]
    NProc[t] = log(max(1, mu[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  
  # Observation model
  for (t in 1:nyears) {
    y[t] ~ dpois(N[t])
  }
}
```

Initialisation des données :
```{r}
bugs.data = list(nyears = nrow(ssm_sim1)+20,
                 y = c(ssm_sim1$y,rep(NA,20)))
```

Paramètres JAGS :
```{r}
bugs.monitor = c("lambda", "sigmaProc", "N", "tauProc")
bugs.chains = 3
bugs.inits = function() {
  list()
}
```

Lancement du modèle.
```{r,results='hide'}
sim_modelexp = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modelexp,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=100000, 
                   n.burnin=20000)
```

On affiche la dynamique de la population sur un graphique.
```{r,warning=FALSE}
sim_modelexp$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               values_to = "value",
               names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter) + 1995)%>%
  arrange(years)%>%
  ggplot()+
  geom_line(aes(x = years, y = medianN), colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq, ymax = hq), fill = "red", alpha = 0.3)+
  geom_point(data = bugs.data %>% as_tibble, aes(x = 1995 + 1:unique(nyears), y = y)) + 
  coord_cartesian(xlim=c(1996,2040),ylim=c(0,1500))+
  theme_bw()+
  labs(title = "Estimated and projected population size",
       subtitle = "Observed population size (black dots)",
       x = "Years",
       y = "Number of wolves")

```

## Avec le modèle logistique

On initialise les paramètres pour la simulation des données
```{r}
nyears = 27
N1 = 30
sigma = 0.15
K = 800
alpha = 0.2
```

On crée un data frame qui contiendra nos données
```{r}
ssm_sim2 = data.frame(Year = 1:nyears,
                       y = numeric(nyears),
                       N = numeric(nyears))

ssm_sim2$N[1] = N1
```

On crée les données pas à pas avec le taux de reproduction $\lambda \sim \text{Normale}(\mu _\lambda,\sigma_\lambda)$ avec $mu_\lambda$ et $\sigma_\lambda$ définis plus tôt.

```{r}
for (t in 1:(nyears-1)){
    Er = exp(alpha * (1 - ssm_sim2$N[t] / K)) * ssm_sim2$N[t]
    ssm_sim2$N[t+1] = rpois(1,Er)
}
for (t in 1:nyears){
  ssm_sim2$y[t]=rpois(1,ssm_sim2$N[t])
}


ggplot(ssm_sim2, aes(x = Year)) +
  geom_point(aes(y = y), colour = "red") +
  geom_line(aes(y = N), colour = "grey30") +
  theme_bw()
```

```{r}
modellogist = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / sigmaProc ^ 2
  alpha ~ dunif(0, 1.0986) #maximum exponential growth rate
  K ~ dunif(1, 1000)         #carrying capacity
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    Er[t-1] = exp(alpha * (1 - N[t-1] / K))
    lambda[t-1] = N[t-1] * Er[t-1]
    N[t] ~ dpois(lambda[t-1])
  }
  # Observation model
  for (t in 1:nyears) {
    y[t] ~ dpois(N[t])
  }
}
```

Initialisation des données :
```{r}
bugs.data = list(nyears = nrow(ssm_sim2)+20,
                 y = c(ssm_sim2$y,rep(NA,20)))
```

Paramètres JAGS :
```{r}
bugs.monitor = c("alpha", "sigmaProc", "tauProc", "K", "lambda", "N")
bugs.chains = 3
init1 = list(alpha = .5, sigmaProc = .25)
init2 = list(alpha = .1, sigmaProc = .05)
init3 = list(alpha = 1, sigmaProc = .45)
bugs.inits = list(init1, init2, init3)
```

Lancement du modèle.
```{r,results='hide'}
sim_modellogist = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modellogist,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=20000, 
                   n.burnin=5000)
```

On affiche la dynamique de la population sur un graphique.
```{r,warning=FALSE}
sim_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               values_to = "value",
               names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter) + 1995)%>%
  arrange(years)%>%
  ggplot()+
  geom_line(aes(x = years, y = medianN), colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq, ymax = hq), fill = "red", alpha = 0.3)+
  geom_point(data = bugs.data %>% as_tibble, aes(x = 1995 + 1:unique(nyears), y = y)) + 
  coord_cartesian(xlim=c(1996,2040))+
  theme_bw()+
  labs(title = "Estimated and projected population size",
       subtitle = "with observed population size (black dots)",
       x = "Years",
       y = "Number of wolves")

```


## En mélangeant les deux modèles

On initialise les paramètres pour la simulation des données
```{r}
nyears = 27
N1 = 30
sigma = 0.15
lambda = 1.15
K = 800
alpha = 0.2
```

On crée un data frame qui contiendra nos données
```{r}
ssm_sim3 = data.frame(Year = 1:nyears,
                       y = numeric(nyears),
                       N = numeric(nyears))

ssm_sim3$N[1] = N1
```

On crée les données pas à pas avec le taux de reproduction $\lambda \sim \text{Normale}(\mu _\lambda,\sigma_\lambda)$ avec $mu_\lambda$ et $\sigma_\lambda$ définis plus tôt.

```{r}
# Modèle exponentiel
for (t in 1:14){
   ssm_sim3$N[t+1] = round(rnorm(1,ssm_sim3$N[t] * lambda,sigma))
}
for (t in 1:15){
  ssm_sim3$y[t]=rpois(1,ssm_sim3$N[t])
}

# Modèle logistique
for (t in 15:nyears){
    Er = exp(alpha * (1 - ssm_sim3$N[t-1] / K)) * ssm_sim3$N[t-1]
    ssm_sim3$N[t] = rpois(1,Er)
}
for (t in 16:nyears){
  ssm_sim3$y[t]=rpois(1,ssm_sim3$N[t])
}

ggplot(ssm_sim3, aes(x = Year)) +
  geom_point(aes(y = y), colour = "red") +
  geom_line(aes(y = N), colour = "grey30") +
  theme_bw()
```

```{r}
modellogist = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / sigmaProc ^ 2
  alpha ~ dunif(0, 1.0986) #maximum exponential growth rate
  K ~ dunif(1, 1000)         #carrying capacity
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears-20)) {
    Er[t-1] = exp(alpha * (1 - N[t-1] / K))
    lambda[t-1] = N[t-1] * Er[t-1]
    N[t] ~ dpois(lambda[t-1])
  }
  # Observation model
  for (t in 1:nyears) {
    y[t] ~ dpois(N[t])
  }
  # Projection
  for (t in (nyears-19):(nyears)) {
    Er[t-1] = exp(alpha * (1 - N[t-1] / K))
    lambda[t-1] = N[t-1] * Er[t-1]
    N[t] ~ dpois(lambda[t-1])
  }
}
```

Initialisation des données :
```{r}
bugs.data = list(nyears = nrow(ssm_sim3)+20,
                 y = c(ssm_sim3$y,rep(NA,20)))
```

Paramètres JAGS :
```{r}
bugs.monitor = c("alpha", "sigmaProc", "tauProc", "K", "lambda", "N")
bugs.chains = 3
init1 = list(alpha = .5, sigmaProc = .25)
init2 = list(alpha = .1, sigmaProc = .05)
init3 = list(alpha = 1, sigmaProc = .45)
bugs.inits = list(init1, init2, init3)
```

Lancement du modèle.
```{r,results='hide'}
sim_modellogist = jags(data = bugs.data,
                   inits = bugs.inits, 
                   parameters.to.save = bugs.monitor,
                   model.file = modellogist,
                   n.chains = bugs.chains, 
                   n.thin=10,
                   n.iter=20000, 
                   n.burnin=5000)
```


On affiche la dynamique de la population sur un graphique.
```{r,warning=FALSE}
sim_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               values_to = "value",
               names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter) + 1995)%>%
  arrange(years)%>%
  ggplot()+
  geom_line(aes(x = years, y = medianN), colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq, ymax = hq), fill = "red", alpha = 0.3)+
  geom_point(data = bugs.data %>% as_tibble, aes(x = 1995 + 1:unique(nyears), y = y)) + 
  coord_cartesian(xlim=c(1996,2040))+
  theme_bw()+
  labs(title = "Estimated population size", 
       subtitle = "Observed population size (black dots)",
       x = "Years",
       y = "Number of wolves")

```


# Simulation de gestion adaptative


## Avec le modèle exponentiel

```{r}
modelexp = function() {
  # Priors
  sigmaProc ~ dunif (0, 10)
  tauProc = 1 / (sigmaProc ^ 2)
  lambda ~ dunif(0, 5)
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model
  for (t in 2:(nyears)) {
    u[t-1] = N[t-1] * (lambda-dH)
    NProc[t] = log(max(1, u[t-1]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  
  # Observation model
  for (t in 1:nyears) {
    y[t] ~ dpois(N[t])
  }
  
    #Projected population
  for (t in (nyears+1):(nyears+5)) {
    u[t-1] = N[t-1] * (lambda-dH)
    NProc[t] = log(max(1, u[t-1]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
}
```

On crée un data frame qui contiendra nos premières données de simulation :
```{r}
dH = c(0,10,20,30)/100
nyears = 25
N1 = 30

ssm_sim5 = data.frame(Year = 1:nyears,
                       y = numeric(nyears),
                       N = numeric(nyears))

ssm_sim5$N[1] = N1
```

```{r,results='hide'}
H = 0
sigma = 0.15
ite = 0
tempH = c()
lambda = 1.2

for (nyears in seq(5, nyears, 5)) {
  # Boucle sur le nombre d'années
  print(nyears)
  ite = ite + 1
  tempH[ite] = H
  
  if (nyears == 5) {
    # Simulation des 5 premières années
    for (t in 1:(nyears - 1)) {
      u = ssm_sim5$N[t] * (lambda - H)
      ssm_sim5$N[t + 1] = rpois(1, u)
    }
  }
  
  if (nyears > 5) {
    # Simulation des années suivantes, 5 par 5
    for (t in (nyears - 5):(nyears - 1)) {
      u = ssm_sim5$N[t] * (lambda - H)
      ssm_sim5$N[t + 1] = rpois(1, u)
    }
  }
  
  for (t in 1:nyears) {
    # Simulation des données observées
    ssm_sim5$y[t] = rpois(1, ssm_sim5$N[t])
  }
  
  # Initialisation des données
  bugs.data = list(nyears = nyears,
                   y = c(ssm_sim5$y[1:nyears], rep(NA, 5)),
                   dH = H)
  # Paramètres JAGS
  bugs.monitor = c("sigmaProc", "tauProc", "lambda", "N")
  bugs.chains = 3
  bugs.inits = function() {
    list()
  }
  
  # Lancement du modèle
  wolf_modelexp = jags(
    data = bugs.data,
    inits = bugs.inits,
    parameters.to.save = bugs.monitor,
    model.file = modelexp,
    n.chains = bugs.chains,
    n.thin = 10,
    n.iter = 100000,
    n.burnin = 20000
  )
  
  #print(wolf_modelexp, intervals = c(2.5 / 100, 50 / 100, 97.5 / 100))
  
  # Taux de reproduction estimé
  lambda = wolf_modelexp$BUGSoutput$median$lambda # lambda estimé sur une période les données observées + une période projeter sur 5 ans
  print(lambda)
  if (lambda<1.2){H=0}
  if(lambda>=1.2 & lambda<1.3){H=0.1}
  if(lambda>=1.3 & lambda<1.4){H=0.2}
  if(lambda>1.4){H=0.3}
  
  print(H)
}

```


```{r}
ggplot(ssm_sim5, aes(x = Year)) +
  geom_point(aes(y = y), colour = "red") +
  geom_line(aes(y = N), colour = "grey30") +
  theme_bw()

tempH
```

```{r,warning=FALSE}
wolf_modelexp$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter))%>%
  arrange(years)%>%
  ggplot()+
  geom_line(aes(x = years, y = medianN), colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq, ymax = hq), fill = "red", alpha = 0.3)+
  geom_point(data = bugs.data %>% as_tibble, aes(x = 1:unique(nyears+5), y = c(ssm_sim5$y,rep(NA,5)))) + 
#  coord_cartesian(ylim=c(0,1500))+
  theme_bw()+
  labs(title = "Estimated population size",
       subtitle = "Observed population size (black dots)",
       x = "Years",
       y = "Number of wolves")

```

## Avec le modèle logisitique

```{r}
modellogist = function() {
  # Priors
  sigmaProc ~ dunif (0, 5)
  tauProc = 1 / sigmaProc ^ 2
  alpha ~ dunif(0, 1.0986) #maximum exponential growth rate
  K ~ dunif(1, 1000)         #carrying capacity
  
  N[1] ~ dgamma(1.0E-6, 1.0E-6)
  
  # Process model 
  for (t in 2:(nyears+5)) {
    u[t-1] = N[t-1] * (1-dH)
    Er[t] = exp(alpha * (1 - u[t-1] / K)) # per capita growth rate is density dependent - Ricker model
    lambda[t] = u[t-1] * Er[t]
    NProc[t] = log(max(1, lambda[t]))
    N[t] ~ dlnorm(NProc[t], tauProc)
  }
  # Observation model
  for (t in 1:(nyears)) {
    y[t] ~ dpois(N[t])
  }
}
```


On crée un data frame qui contiendra nos premières données de simulation :
```{r}
nyears = 25
N1 = 30

ssm_sim4 = data.frame(Year = 1:nyears,
                       y = numeric(nyears),
                       N = numeric(nyears),
                      ybis = numeric(nyears),
                      Nbis = numeric(nyears))

ssm_sim4$N[1] = N1
ssm_sim4$Nbis[1] = N1
```


```{r,results='hide'}
# Paramètres initiaux
pas = 1
H = 0
sigma = 0.15
K = 800
alpha = 0.5
ite = 0
tempH = c()
NAMharvest = 0.15

# Lancement du modèle
for (nyears in seq(2,nyears,pas)) { # Boucle sur le nombre de tranches d'années parcourues
  ite = ite+1
  tempH[ite] = H # Enregistre les taux de prélevement pour chaque année
  
  # Simulation des effectifs
  if (nyears <= 5) { # Initialisation des effectifs, sans prélevement sur les 5 premières années
    for (t in 1:(nyears - 1)) {
      u = ssm_sim4$N[t]
      
      Er = exp(alpha * (1 - u/ K)) * u
      
      ssm_sim4$N[t+1] = rpois(1,Er)
      ssm_sim4$Nbis[t+1] = rpois(1,Er)
    }
  }
  
  if(nyears > 5){ # Suite de la simulation des effectifs entre les années 6 et 25
    for (t in (nyears - pas):(nyears - 1)) {
      u = ssm_sim4$N[t]*(1-H)             # Taux de prélevement adaptatif
      v = ssm_sim4$Nbis[t]*(1-NAMharvest) # Taux de prélevement constant
      
      Er = exp(alpha * (1 - c(u,v)/ K)) * c(u,v)      
      
      ssm_sim4$N[t+1] = rpois(1,Er[1])
      ssm_sim4$Nbis[t+1] = rpois(1,Er[2])    
      }
    }
  # Simulation des effecitfs observés
  for (t in 1:nyears){
    ssm_sim4$y[t]=rpois(1,ssm_sim4$N[t])
    ssm_sim4$ybis[t]=rpois(1,ssm_sim4$Nbis[t])
  }
  
  # Début de l'estimation par approche bayésienne
    # Initialisation des données
    bugs.data = list(nyears = nyears,
                     y = c(ssm_sim4$y[1:nyears],rep(NA,5)),
                     dH = H)
    
    # Paramètres JAGS
    bugs.monitor = c("alpha", "sigmaProc", "tauProc", "K", "N")
    bugs.chains = 3
    init1 = list(alpha = .5, sigmaProc = .25)
    init2 = list(alpha = .1, sigmaProc = .05)
    init3 = list(alpha = 1, sigmaProc = .45)
    bugs.inits = list(init1, init2, init3)
    
    # Lancement du modèle
    
    wolf_modellogist = jags(
      data = bugs.data,
      inits = bugs.inits,
      parameters.to.save = bugs.monitor,
      model.file = modellogist,
      n.chains = bugs.chains,
      n.thin = 10,
      n.iter = 20000,
      n.burnin = 5000
    )
    output1 = wolf_modellogist$BUGSoutput$sims.matrix
    
    # Calcul du taux de reproduction estimé
    Nest = wolf_modellogist$BUGSoutput$median$N
    l = length(Nest)
    lamb = c()
    for (t in 1:(l-5)) {
      lamb[t] = Nest[t+1] / Nest[t]}
    lambda = mean(lamb)
    print(lambda)
  
    # Conditions de modification du taux de prélevement
    if (lambda < 1.2) {H = 0}
    if (lambda >= 1.2 & lambda < 1.3) {H = 0.1}
    if (lambda >= 1.3 & lambda < 1.4) {H = 0.2}
    if (lambda > 1.4) {H = 0.3}
  
  print(H)
}

```

```{r}
ggplot(ssm_sim4, aes(x = Year)) +
  geom_point(aes(y = y), colour = "red") +
  geom_line(aes(y = N), colour = "red4", lty = "dashed") +
  geom_point(aes(y = ybis), colour = "blue") +
  geom_line(aes(y = Nbis), colour = "blue4", lty = "dashed") +
  theme_bw()

tempH
```

```{r,warning=FALSE}
wolf_modellogist$BUGSoutput$sims.matrix%>%
  as_tibble() %>%
  pivot_longer(cols = everything(),  values_to = "value", names_to = "parameter") %>%
  filter(str_detect(parameter, "N")) %>%
  group_by(parameter) %>%
  summarize(medianN = median(value),
            lq = quantile(value, probs = 2.5/100),
            hq = quantile(value, probs = 97.5/100))%>%
  mutate(years = parse_number(parameter))%>%
  arrange(years)%>%
  ggplot()+
  geom_line(aes(x = years, y = medianN), colour = "red", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq, ymax = hq), fill = "red", alpha = 0.3)+
  geom_point(data = bugs.data %>% as_tibble, aes(x = 1:unique(nyears+5), y = c(ssm_sim4$y,rep(NA,5)))) + 
  theme_bw()+
  labs(title = "Estimated population size",
       subtitle = "Observed population size (black dots)",
       x = "Years",
       y = "Number of wolves")

```

```{r}
tempH
```

## Comparaison avec une gestion non-adaptative

On prend le même jeu de données simulé pécédemment et on applique un taux de prélevement constant chaque année (15% pour coller avec le taux de prélevement observé sur les loups en France).


```{r,results='hide'}
# Initialisation des données
bugs.data = list(nyears = nyears,
                 y = c(ssm_sim4$ybis[1:nyears], rep(NA, 5)),
                 dH = NAMharvest)

wolf_modellogist = jags(
  data = bugs.data,
  inits = bugs.inits,
  parameters.to.save = bugs.monitor,
  model.file = modellogist,
  n.chains = bugs.chains,
  n.thin = 10,
  n.iter = 20000,
  n.burnin = 5000
)

output2 = wolf_modellogist$BUGSoutput$sims.matrix %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               values_to = "value",
               names_to = "parameter2") %>%
  filter(str_detect(parameter2, "N")) %>%
  group_by(parameter2) %>%
  summarize(
    medianN2 = median(value),
    lq2 = quantile(value, probs = 2.5 / 100),
    hq2 = quantile(value, probs = 97.5 / 100)
  ) %>%
  mutate(years = parse_number(parameter2)) %>%
  arrange(years)
```

```{r,warning=FALSE}
output1 = output1 %>%
  as_tibble() %>%
  pivot_longer(cols = everything(),
               values_to = "value",
               names_to = "parameter1") %>%
  filter(str_detect(parameter1, "N")) %>%
  group_by(parameter1) %>%
  summarize(
    medianN1 = median(value),
    lq1 = quantile(value, probs = 2.5 / 100),
    hq1 = quantile(value, probs = 97.5 / 100)
  ) %>%
  mutate(years = parse_number(parameter1)) %>%
  arrange(years)


output = output1 %>% left_join(output2)

  ggplot(output) +
  geom_point(data = ssm_sim4, aes(x = seq(1, 25), y = y), colour = "red") +
  geom_point(data = ssm_sim4, aes(x = seq(1, 25), y = ybis), colour = "blue")+
  geom_line(aes(x = years, y = medianN1), colour = "red4", lty = "dashed")+
  geom_line(aes(x = years, y = medianN2), colour = "blue4", lty = "dashed")+
  geom_ribbon(aes(x = years, ymin = lq1, ymax = hq1), fill = "red", alpha = 0.3)+
  geom_ribbon(aes(x = years, ymin = lq2, ymax = hq2), fill = "blue", alpha = 0.3)+
  # facet_wrap(~medianN,labeller = variable_labeller)+
  theme_bw()+
  labs(title = "Estimated and projected population size",
       subtitle = "For adaptive management (red) and for a constant harvest rate (blue)",
       x = "Years",
       y = "Number of wolves")
```
```{r}
# Ranger les taux de croissances de chaque méthode
lambda1=c()
lambda2=c()

for (t in 1:(nyears-1)){
  lambda1[t]=output1$medianN1[t+1]/output1$medianN1[t]
  lambda2[t]=output2$medianN2[t+1]/output2$medianN2[t]
}

# Compter le nombre de fois que le taux de croissance n'est pas dans l'objectif [1,1.2]
fail1=0
fail2=0
for (t in 1:length(lambda1)){
  if (between(lambda1[t],1,1.2)==FALSE){fail1=fail1+1}
  if (between(lambda2[t],1,1.2)==FALSE){fail2=fail2+1}
}

fail1
fail2
```
