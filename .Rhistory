} #i
# Full capture-recapture matrix
CH <- CH.sur * CH.p
# Remove individuals never captured
cap.sum <- rowSums(CH)
never <- which(cap.sum == 0)
CH <- CH[-never,]
for(i in 1:N){
sup=numeric()
k=1
if (1 %in%! CH[i,]){
sup [k] = i
k = k+1
}
}
CH[1]
CH[1,]
CH
knitr::opts_chunk$set(echo = TRUE)
library(R2jags)
library(tidyverse)
modelCMR = function() {
#--------------------------------------
# Parameters:
# phi: survival probability
# gamma: removal entry probability
# p1: capture probability for the more observed group
# p2: capture probability for the less observed group
# pi: rate of individuals in group 1
#--------------------------------------
# States (S):
# 1 not yet entered
# 2 alive
# 3 dead
# Observations (O):
# 1 seen
# 2 not seen
#--------------------------------------
# Priors and constraints
for (t in 1:(n.occasions-1)){
phi[t] <- mean.phi
gamma[t] ~ dunif(0, 1) # Prior for entry probabilities
p1[t] ~ dunif(0, 1)    # Prior for capture probability of group 1
p2[t] ~ dunif(0,p1[t])    # Prior for capture probability of group 2
}
mean.phi ~ dunif(0, 1)    # Prior for mean survival
pi ~ dunif(0,1)     # Prior for rate of individuals in group 1
# Define state-transition and observation matrices
for (i in 1:M){
# Define probabilities of state S(t+1) given S(t)
for (t in 1:(n.occasions-1)){
ps[1,i,t,1] <- 1-gamma[t]
ps[1,i,t,2] <- gamma[t]
ps[1,i,t,3] <- 0
ps[2,i,t,1] <- 0
ps[2,i,t,2] <- phi[t]
ps[2,i,t,3] <- 1-phi[t]
ps[3,i,t,1] <- 0
ps[3,i,t,2] <- 0
ps[3,i,t,3] <- 1
# Define probabilities of O(t) given S(t)
po[1,i,t,1,1] <- 0
po[1,i,t,2,1] <- 1
po[2,i,t,1,1] <- p1[t]
po[2,i,t,2,1] <- 1-p1[t]
po[3,i,t,1,1] <- 0
po[3,i,t,2,1] <- 1
po[1,i,t,1,2] <- 0
po[1,i,t,2,2] <- 1
po[2,i,t,1,2] <- p2[t]
po[2,i,t,2,2] <- 1-p2[t]
po[3,i,t,1,2] <- 0
po[3,i,t,2,2] <- 1
} #t
} #i
# Likelihood
for (i in 1:M){
group[i] ~ dbern(pi) # Draw a random group
# Define latent state at first occasion
z[i,1] <- 1   # Make sure that all M individuals are in state 1 at t=1
for (t in 2:n.occasions){
# State process: draw S(t) given S(t-1)
z[i, t] ~ dcat(ps[z[i, t - 1], i, t - 1, ])
# Observation process: draw O(t) given S(t)
y[i, t] ~ dcat(po[z[i, t], i, t - 1, , group[i] + 1])
} #t
} #i
# Calculate derived population parameters
mean.p1 = sum(p1) / n.occasions
mean.p2 = sum(p2) / n.occasions
for (t in 1:(n.occasions-1)){
qgamma[t] <- 1-gamma[t]
}
cprob[1] <- gamma[1]
for (t in 2:(n.occasions-1)){
cprob[t] <- gamma[t] * prod(qgamma[1:(t-1)])
} #t
psi <- sum(cprob[])            # Inclusion probability
for (t in 1:(n.occasions-1)){
b[t] <- cprob[t] / psi      # Entry probability
} #t
for (i in 1:M){
for (t in 2:n.occasions){
al[i,t-1] <- equals(z[i,t], 2)
} #t
for (t in 1:(n.occasions-1)){
d[i,t] <- equals(z[i,t]-al[i,t],0)
} #t
alive[i] <- sum(al[i,])
} #i
for (t in 1:(n.occasions-1)){
N[t] <- sum(al[,t])        # Actual population size
B[t] <- sum(d[,t])         # Number of entries
} #t
for (i in 1:M){
w[i] <- 1-equals(alive[i],0)
} #i
Nsuper <- sum(w[])            # Superpopulation size
}
n.occasions <- 7                        # Number of capture occasions
N <- 400                                 # Superpopulation size
phi <- rep(0.7, n.occasions-1)           # Survival probabilities
b <- c(0.34, rep(0.11, n.occasions-1))   # Entry probabilities
p <- rep(0.5, n.occasions)               # Capture probabilities
p_class1 <- 0.7 # detection class 1
p_class2 <- 0.4 # detection class 2
prop_class1 <- 0.6 # pi
PHI <- matrix(rep(phi, (n.occasions-1)*N), ncol = n.occasions-1, nrow = N, byrow = T)
P = matrix(NA,ncol = n.occasions, nrow = N, byrow = T)
which_mixture <- rep(NA, N)
for (i in 1:N) {
which_mixture[i] <-
rbinom(1, 1, prop_class1) # assign ind i to a class with prob pi
if (which_mixture[i] == 1) {
P[i,] <- rep(p_class1,n.occasions)
}
else {
P[i,] <- rep(p_class2,n.occasions)
}
}
#P <- matrix(rep(p, n.occasions*N), ncol = n.occasions, nrow = N, byrow = T)
B <- rmultinom(1, N, b) # Generate no. of entering ind. per occasion
n.occasions <- dim(PHI)[2] + 1
CH.sur <- CH.p <- matrix(0, ncol = n.occasions, nrow = N)
CH.sur
# Define a vector with the occasion of entering the population
ent.occ <- numeric()
for (t in 1:n.occasions){
ent.occ <- c(ent.occ, rep(t, B[t]))
}
# Simulating survival
for (i in 1:N){
CH.sur[i, ent.occ[i]] <- 1   # Write 1 when ind. enters the pop.
if (ent.occ[i] == n.occasions) next
for (t in (ent.occ[i]+1):n.occasions){
# Bernoulli trial: has individual survived occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
#ifelse (sur==1, CH.sur[i,t] <- 1, break)
if (sur==1){CH.sur[i,t]=1}
else{CH.sur[i,t]=2 ; break}
} #t
} #i
CH.sur
# Simulating capture
for (i in 1:N){
CH.p[i,] <- rbinom(n.occasions, 1, P[i,])
} #i
# Full capture-recapture matrix
CH <- CH.sur * CH.p
CH
# Remove individuals never captured
cap.sum <- rowSums(CH)
never <- which(cap.sum == 0)
CH <- CH[-never,]
CH
for(i in 1:N){
sup=numeric()
k=1
if (1 %in%! CH[i,]){
sup [k] = i
k = k+1
}
}
CH
CH[1,]
1 %in% CH
for(i in 1:N){
sup=numeric()
k=1
if ((1 %in% CH[i,])==FALSE){
sup [k] = i
k = k+1
}
}
typeof(CH[1,])
CH[1,]
for(i in 1:(N-1)){
sup=numeric()
k=1
if ((1 %in% CH[i,])==FALSE){
sup [k] = i
k = k+1
}
}
n.occasions <- 7                        # Number of capture occasions
N <- 400                                 # Superpopulation size
phi <- rep(0.7, n.occasions-1)           # Survival probabilities
b <- c(0.34, rep(0.11, n.occasions-1))   # Entry probabilities
p <- rep(0.5, n.occasions)               # Capture probabilities
p_class1 <- 0.7 # detection class 1
p_class2 <- 0.4 # detection class 2
prop_class1 <- 0.6 # pi
PHI <- matrix(rep(phi, (n.occasions-1)*N), ncol = n.occasions-1, nrow = N, byrow = T)
P = matrix(NA,ncol = n.occasions, nrow = N, byrow = T)
which_mixture <- rep(NA, N)
for (i in 1:N) {
which_mixture[i] <-
rbinom(1, 1, prop_class1) # assign ind i to a class with prob pi
if (which_mixture[i] == 1) {
P[i,] <- rep(p_class1,n.occasions)
}
else {
P[i,] <- rep(p_class2,n.occasions)
}
}
#P <- matrix(rep(p, n.occasions*N), ncol = n.occasions, nrow = N, byrow = T)
simul.js <- function(PHI, P, b, N){
B <- rmultinom(1, N, b) # Generate no. of entering ind. per occasion
n.occasions <- dim(PHI)[2] + 1
CH.sur <- CH.p <- matrix(0, ncol = n.occasions, nrow = N)
# Define a vector with the occasion of entering the population
ent.occ <- numeric()
for (t in 1:n.occasions){
ent.occ <- c(ent.occ, rep(t, B[t]))
}
# Simulating survival
for (i in 1:N){
CH.sur[i, ent.occ[i]] <- 1   # Write 1 when ind. enters the pop.
if (ent.occ[i] == n.occasions) next
for (t in (ent.occ[i]+1):n.occasions){
# Bernoulli trial: has individual survived occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
#ifelse (sur==1, CH.sur[i,t] <- 1, break)
if (sur==1){CH.sur[i,t]=1}
else{CH.sur[i,t]=2 ; break}
} #t
} #i
# Simulating capture
for (i in 1:N){
CH.p[i,] <- rbinom(n.occasions, 1, P[i,])
} #i
# Full capture-recapture matrix
CH <- CH.sur * CH.p
# Remove individuals never captured
cap.sum <- rowSums(CH)
never <- which(cap.sum == 0)
CH <- CH[-never,]
if (min(which(x==2))<min(which(x==1))){CH}
Nt <- colSums(CH.sur)    # Actual population size
return(list(CH=CH, B=B, N=Nt))
}
simul.js <- function(PHI, P, b, N){
B <- rmultinom(1, N, b) # Generate no. of entering ind. per occasion
n.occasions <- dim(PHI)[2] + 1
CH.sur <- CH.p <- matrix(0, ncol = n.occasions, nrow = N)
# Define a vector with the occasion of entering the population
ent.occ <- numeric()
for (t in 1:n.occasions){
ent.occ <- c(ent.occ, rep(t, B[t]))
}
# Simulating survival
for (i in 1:N){
CH.sur[i, ent.occ[i]] <- 1   # Write 1 when ind. enters the pop.
if (ent.occ[i] == n.occasions) next
for (t in (ent.occ[i]+1):n.occasions){
# Bernoulli trial: has individual survived occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
#ifelse (sur==1, CH.sur[i,t] <- 1, break)
if (sur==1){CH.sur[i,t]=1}
else{CH.sur[i,t]=2 ; break}
} #t
} #i
# Simulating capture
for (i in 1:N){
CH.p[i,] <- rbinom(n.occasions, 1, P[i,])
} #i
# Full capture-recapture matrix
CH <- CH.sur * CH.p
# Remove individuals never captured
cap.sum <- rowSums(CH)
for(i in 1:(N)){
sup=numeric()
k=1
if ((1 %in% CH[i,])==FALSE){
sup [k] = i
k = k+1
}
}
never <- which(cap.sum == 0)
CH <- CH[-never,]
Nt <- colSums(CH.sur)    # Actual population size
return(list(CH=CH, B=B, N=Nt))
}
sim <- simul.js(PHI, P, b, N)
CH <- sim$CH
CH
# Add dummy occasion
CH.du <- cbind(rep(0, dim(CH)[1]), CH)
my.z.init <- CH.du
first.one <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1)))
last.one  <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) max(which(x == 1)))
for(i in 1:nrow(my.z.init)) {
my.z.init[i, first.one[i]  : last.one[i]] = 2
# 2 indique que l'on est sûr que l'individu est vivant
if(first.one[i] > 1) my.z.init[i,1  : (first.one[i] - 1) ] = 1
# 1 indique que l'on n'a toujours pas observé l'individu (pas observé ou pas encore né)
if(last.one[i] < ncol(my.z.init)) my.z.init[i, (last.one[i] + 1) : ncol(my.z.init)    ] = 3
# 3 indique que l'on n'observe plus l'individu (pas observé ou mort)
}
first.one <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1)))
CH.du
first.one <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1)))
simul.js <- function(PHI, P, b, N){
B <- rmultinom(1, N, b) # Generate no. of entering ind. per occasion
n.occasions <- dim(PHI)[2] + 1
CH.sur <- CH.p <- matrix(0, ncol = n.occasions, nrow = N)
# Define a vector with the occasion of entering the population
ent.occ <- numeric()
for (t in 1:n.occasions){
ent.occ <- c(ent.occ, rep(t, B[t]))
}
# Simulating survival
for (i in 1:N){
CH.sur[i, ent.occ[i]] <- 1   # Write 1 when ind. enters the pop.
if (ent.occ[i] == n.occasions) next
for (t in (ent.occ[i]+1):n.occasions){
# Bernoulli trial: has individual survived occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
#ifelse (sur==1, CH.sur[i,t] <- 1, break)
if (sur==1){CH.sur[i,t]=1}
else{CH.sur[i,t]=2 ; break}
} #t
} #i
# Simulating capture
for (i in 1:N){
CH.p[i,] <- rbinom(n.occasions, 1, P[i,])
} #i
# Full capture-recapture matrix
CH <- CH.sur * CH.p
# Remove individuals never captured
for(i in 1:(N)){
sup=numeric()
k=1
if ((1 %in% CH[i,])==FALSE){
sup [k] = i
k = k+1
}
}
CH = CH[-sup]
cap.sum <- rowSums(CH)
never <- which(cap.sum == 0)
CH <- CH[-never,]
Nt <- colSums(CH.sur)    # Actual population size
return(list(CH=CH, B=B, N=Nt))
}
simul.js <- function(PHI, P, b, N){
B <- rmultinom(1, N, b) # Generate no. of entering ind. per occasion
n.occasions <- dim(PHI)[2] + 1
CH.sur <- CH.p <- matrix(0, ncol = n.occasions, nrow = N)
# Define a vector with the occasion of entering the population
ent.occ <- numeric()
for (t in 1:n.occasions){
ent.occ <- c(ent.occ, rep(t, B[t]))
}
# Simulating survival
for (i in 1:N){
CH.sur[i, ent.occ[i]] <- 1   # Write 1 when ind. enters the pop.
if (ent.occ[i] == n.occasions) next
for (t in (ent.occ[i]+1):n.occasions){
# Bernoulli trial: has individual survived occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
#ifelse (sur==1, CH.sur[i,t] <- 1, break)
if (sur==1){CH.sur[i,t]=1}
else{CH.sur[i,t]=2 ; break}
} #t
} #i
# Simulating capture
for (i in 1:N){
CH.p[i,] <- rbinom(n.occasions, 1, P[i,])
} #i
# Full capture-recapture matrix
CH <- CH.sur * CH.p
# Remove individuals never captured
for(i in 1:(N)){
sup=numeric()
k=1
if ((1 %in% CH[i,])==FALSE){
sup [k] = i
k = k+1
}
}
CH = CH[-sup,]
cap.sum <- rowSums(CH)
never <- which(cap.sum == 0)
CH <- CH[-never,]
Nt <- colSums(CH.sur)    # Actual population size
return(list(CH=CH, B=B, N=Nt))
}
sim <- simul.js(PHI, P, b, N)
CH <- sim$CH
CH
# Add dummy occasion
CH.du <- cbind(rep(0, dim(CH)[1]), CH)
my.z.init <- CH.du
first.one <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1)))
last.one  <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) max(which(x == 1)))
for(i in 1:nrow(my.z.init)) {
my.z.init[i, first.one[i]  : last.one[i]] = 2
# 2 indique que l'on est sûr que l'individu est vivant
if(first.one[i] > 1) my.z.init[i,1  : (first.one[i] - 1) ] = 1
# 1 indique que l'on n'a toujours pas observé l'individu (pas observé ou pas encore né)
if(last.one[i] < ncol(my.z.init)) my.z.init[i, (last.one[i] + 1) : ncol(my.z.init)    ] = 3
# 3 indique que l'on n'observe plus l'individu (pas observé ou mort)
}
# Add dummy occasion
CH.du <- cbind(rep(0, dim(CH)[1]), CH)
my.z.init <- CH.du
first.one <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1)))
first.one
CH.du
simul.js <- function(PHI, P, b, N){
B <- rmultinom(1, N, b) # Generate no. of entering ind. per occasion
n.occasions <- dim(PHI)[2] + 1
CH.sur <- CH.p <- matrix(0, ncol = n.occasions, nrow = N)
# Define a vector with the occasion of entering the population
ent.occ <- numeric()
for (t in 1:n.occasions){
ent.occ <- c(ent.occ, rep(t, B[t]))
}
# Simulating survival
for (i in 1:N){
CH.sur[i, ent.occ[i]] <- 1   # Write 1 when ind. enters the pop.
if (ent.occ[i] == n.occasions) next
for (t in (ent.occ[i]+1):n.occasions){
# Bernoulli trial: has individual survived occasion?
sur <- rbinom(1, 1, PHI[i,t-1])
#ifelse (sur==1, CH.sur[i,t] <- 1, break)
if (sur==1){CH.sur[i,t]=1}
else{CH.sur[i,t]=2 ; break}
} #t
} #i
# Simulating capture
for (i in 1:N){
CH.p[i,] <- rbinom(n.occasions, 1, P[i,])
} #i
# Full capture-recapture matrix
CH <- CH.sur * CH.p
# Remove individuals never captured
cap.sum <- rowSums(CH)
never <- which(cap.sum == 0)
CH <- CH[-never,]
Nt <- colSums(CH.sur)    # Actual population size
return(list(CH=CH, B=B, N=Nt))
}
sim <- simul.js(PHI, P, b, N)
CH <- sim$CH
CH
# Add dummy occasion
CH.du <- cbind(rep(0, dim(CH)[1]), CH)
my.z.init <- CH.du
first.one <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) min(which(x == 1 | x==2)))
last.one  <- apply(my.z.init[,1:ncol(CH.du)], 1, function(x) max(which(x == 1 | x==2)))
for(i in 1:nrow(my.z.init)) {
my.z.init[i, first.one[i]  : last.one[i]] = 2
# 2 indique que l'on est sûr que l'individu est vivant
if(first.one[i] > 1) my.z.init[i,1  : (first.one[i] - 1) ] = 1
# 1 indique que l'on n'a toujours pas observé l'individu (pas observé ou pas encore né)
if(last.one[i] < ncol(my.z.init)) my.z.init[i, (last.one[i] + 1) : ncol(my.z.init)    ] = 3
# 3 indique que l'on n'observe plus l'individu (pas observé ou mort)
}
# Augment data
nz <- 150
CH.ms <- rbind(CH.du, matrix(0, ncol = dim(CH.du)[2], nrow = nz))
# Recode CH matrix: a 0 is not allowed in WinBUGS!
#CH.ms[CH.ms==2] <- 3
CH.ms[CH.ms==0] <- 2                     # Not seen = 2, seen = 1
my.z.init.ms <- rbind(my.z.init, matrix(0, ncol = dim(my.z.init)[2], nrow = nz))
my.z.init.ms[my.z.init.ms==0] <- 1
my.z.init.ms
# Initialisation des données
bugs.data = list(n.occasions = dim(CH.ms)[2],
y = CH.ms,
M = dim(CH.ms)[1])
# Parameters JAGS
bugs.monitor = c("mean.p1","mean.p2" ,"mean.phi", "b", "Nsuper", "N", "B","pi")
bugs.chains = 2
bugs.inits = function() {
list(mean.phi = runif(1, 0, 1),
# p1 = runif(1, 0, 1),
# p2 = runif(1,0,1),
z = cbind(rep(NA, dim(my.z.init.ms)[1]), my.z.init.ms[,-1]))
}
# Lancement du modèle
wolf_modelCMR = jags(data = bugs.data,
inits = bugs.inits,
parameters.to.save = bugs.monitor,
model.file = modelCMR,
n.chains = bugs.chains,
n.thin=1,
n.iter=2000,
n.burnin=500)
print(wolf_modelCMR, intervals = c(2.5/100, 50/100, 97.5/100))
